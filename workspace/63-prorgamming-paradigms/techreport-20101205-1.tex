% Programming Paradigms

% The Clever Algorithms Project: http://www.CleverAlgorithms.com
% (c) Copyright 2010 Jason Brownlee. Some Rights Reserved. 
% This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.

\documentclass[a4paper, 11pt]{article}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{url}
\usepackage[pdftex,breaklinks=true,colorlinks=true,urlcolor=blue,linkcolor=blue,citecolor=blue,]{hyperref}
\usepackage{geometry}
\usepackage[ruled, linesnumbered]{../algorithm2e}
\usepackage{listings} 
\usepackage{textcomp}
\ifx\pdfoutput\@undefined\usepackage[usenames,dvips]{color}
\else\usepackage[usenames,dvipsnames]{color}
\lstset{basicstyle=\footnotesize\ttfamily,numbers=left,numberstyle=\tiny,frame=single,columns=flexible,upquote=true,showstringspaces=false,tabsize=2,captionpos=b,breaklines=true,breakatwhitespace=true,keywordstyle=\color{blue},stringstyle=\color{ForestGreen}}
\geometry{verbose,a4paper,tmargin=25mm,bmargin=25mm,lmargin=25mm,rmargin=25mm}

% Dear template user: fill these in
\newcommand{\myreporttitle}{Programming Paradigms}
\newcommand{\myreportauthor}{Jason Brownlee}
\newcommand{\myreportemail}{jasonb@CleverAlgorithms.com}
\newcommand{\myreportproject}{The Clever Algorithms Project\\\url{http://www.CleverAlgorithms.com}}
\newcommand{\myreportdate}{20101205}
\newcommand{\myreportfulldate}{December 05, 2010}
\newcommand{\myreportversion}{1}
\newcommand{\myreportlicense}{\copyright\ Copyright 2010 Jason Brownlee. Some Rights Reserved. This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 2.5 Australia License.}

% leave this alone, it's templated baby!
\title{{\myreporttitle}\footnote{\myreportlicense}}
\author{\myreportauthor\\{\myreportemail}\\\small\myreportproject}
\date{\myreportfulldate\\{\small{Technical Report: CA-TR-{\myreportdate}-\myreportversion}}}
\begin{document}
\maketitle

% write a summary sentence for each major section
\section*{Abstract} 
% project
The Clever Algorithms project aims to describe a large number of Artificial Intelligence algorithms in a complete, consistent, and centralized manner, to improve their general accessibility. 
% template
The project makes use of a standardized algorithm description template that uses well-defined topics that motivate the collection of specific and useful information about each algorithm described.
% report
This report considers the use of a range of different programming paradigms used when realizing an algorithm as an implementation.

\begin{description}
	\item[Keywords:] {\small\texttt{Clever, Algorithms, Programming, Paradigms}}
\end{description} 

% summarise the document breakdown with cross references
\section{Introduction}
\label{sec:introduction}
% project
The Clever Algorithms project aims to describe a large number of algorithms from the fields of Computational Intelligence, Biologically Inspired Computation, and Metaheuristics in a complete, consistent and centralized manner \cite{Brownlee2010}.
% description
The project requires all algorithms to be described using a standardized template that includes a fixed number of sections, each of which is motivated by the presentation of specific information about the technique \cite{Brownlee2010a}.
% this report
This report considers the use of a range of different programming paradigms for implementing the algorithms described in this project.

This report discusses a number of standard programming paradigms that may be used to implement the algorithms described in the Clever Algorithms Project. Each paradigm is described and an example implementation is provided using the Genetic Algorithm as a context.

% Procedural
\section{Procedural Programming}
All algorithms in the Clever Algorithms project were implemented using a procedural programming paradigm in the Ruby Programming Language \cite{Brownlee2010au}. A procedural representation was chosen to provide the most transferrable instantiation of the algorithm. Many languages support the procedural paradigm and procedural code examples are expected to be easily ported to popular paradigms such as object-oriented and functional.

\subsection{Description}
The procedural programming paradigm is concerned with defining a linear procedure or sequence of programming statements. A key feature of the paradigm is the partitioning of functionality into small discrete re-usable modules called procedures (subroutines or functions) that act like small programs themselves with their own scope, inputs and outputs. A procedural code example is executed from a single point of control or entry point which calls out into declared procedures, which in turn may call other procedures.

benefits?

\subsection{Example}
Listing~\ref{ga_procedural} provides an example of the Genetic Algorithm implemented in the Ruby Programming Language using the procedural programming paradigm (taken from \cite{Brownlee2010p}).  
% problem
The demonstration problem is a maximizing binary optimization problem called OneMax that seeks a binary string of unity (all `1' bits). The objective function provides only an indication of the number of correct bits in a candidate string, not the positions of the correct bits.
% algorithm
The Genetic Algorithm is implemented with a conservative configuration including binary tournament selection for the selection operator, uniform crossover for the recombination operator, and point mutations for the mutation operator.

% the listing
\lstinputlisting[firstline=7,language=ruby,caption=Genetic Algorithm in the Ruby Programming Language using the Procedural Programming Paradigm, label=ga_procedural]{../../src/algorithms/evolutionary/genetic_algorithm.rb}

% Object-Oriented
\section{Object-Oriented Programming}
% overview
This section considers the implementation of algorithms from the Clever Algorithms project in the Object-Oriented Programming Paradigm.

% description
\subsection{Description}
The Object-Oriented Programming (OOP) paradigm is concerned with modeling problems in terms of entities called objects that have attributes and behaviors (data and methods) that may interact with other entities via message passing (calling methods on other entities). An object defines a class or template for the entity, which is instantiated or constructed and then may be used in the program.

Objects can extend other objects, inheriting some or all of the attributes and behaviors from the parent providing specific modular reuse. Objects can be treated as a parent type (an object in its inheritance tree) allowing the use or application of the objects in the program without the caller knowing the specifics of the behavior or data inside the object. This general property is called polymorphism, which exploits the encapsulation of attributes and behavior within objects and their capability of being treated (viewed or interacted with) as a parent type.

Organizing functionality into objects allows for additional constructs such as abstract types where functionality is only partially defined and must be completed by descendant objects, overriding where descending objects re-define behavior defined in a parent object, and static classes and behaviors where behavior is executed on the object template rather than the object instance. 

For more information on Object-Oriented programming and software design refer to a good text book on the subject, such as Booch \cite{Booch1997} or Meyer \cite{Meyer1997}.

There are common ways of solving discrete problems using object-oriented programs called patterns. They are organizations of behavior and data that have been abstracted and presented as a solution or idiom for a class of problem. The Strategy Pattern is an Object-oriented pattern that is suited to implementing an algorithm. This pattern is intended to encapsulate the behavior of an algorithm as a strategy object where different strategies can be used interchangeably on a given context or problem domain. This strategy can be useful in situations where the performance or capability of a range of different techniques needs to be assessed on a given problem (such as algorithm racing or bake-off's). Additionally, the problem or context can also be modelled as an interchangeable object, allowing both algorithms and problems to be used interchangeably. This method is used in Object-Oriented algorithm frameworks.

For more information on the strategy pattern or Object-Oriented design patterns in general, refer to the so-called gang-of-four design patterns book \cite{Gamma1995}.

\subsection{Example}
Listing~\ref{ga_oop} provides an example of the Genetic Algorithm implemented in the Ruby Programming Language using the Object-Oriented Programming Paradigm. 

The implementation defines a general problem and strategy classes that define their behavioral expectations. A \texttt{OneMax} problem class is defined as is a \texttt{GeneticAlgorithm} strategy class. The algorithm makes few assumptions of the problem other than it can assess candidate solutions and indicate the number of bits a candidate solution should require. The problem makes very few assumptions about candidate solutions other than they are hash maps that contain a binary string and fitness key-value pairs. The use of the Object-Oriented strategy pattern means that a new algorithm could easily be defined to work with the defined problem, and that new problems could be defined for the Genetic Algorithm to execute.

Note that Ruby does not support abstract classes, so this construct is simulated by defining methods that raise an exception if they are not overridden by descendant classes.

% the listing
\lstinputlisting[firstline=7,language=ruby,caption=Genetic Algorithm in the Ruby Programming Language using the Object-Oriented Programming Paradigm, label=ga_oop]{../../src/programming_paradigms/oop.rb}

\section{Flow Programming}
% overview
This section considers the implementation of algorithms from the Clever Algorithms project in the Flow Programming Paradigm.

% description
\subsection{Description}
Flow or pipeline programming involves chaining a sequence of smaller programs together and allowing a flow of information through the sequence in order to perform the desired computation. 

% Functional
\section{Functional}

% Agent-Oriented
\section{Agent-Oriented}

% Meta-Programming
\section{Meta-Programming}



\section{Map Reduce}
A GA under a map reduce paradigm.

\section{Other Paradigms}
A number of popular and common programming paradigms have been considered in this report, although many more have not been described. This section lists some additional popular and common programming paradigms and gives a brief indication of how the paradigm may be considered for implementing an algorithm.

\begin{itemize}
	\item \textbf{Structured Programming}: asdf
	\item \textbf{Logic Programming}: asdf
	\item \textbf{Declarative Programming}: asdf
	\item \textbf{Aspect-Oriented Programming}: asdf
	\item \textbf{Event-Driven Programming}: asdf
\end{itemize}

% summarise the document message and areas for future consideration
\section{Conclusions}
\label{sec:conclusions}
% overview
This report considered the implementation of Clever Algorithms in a range of common and popular programming languages. 


% bibliography
\bibliographystyle{plain}
\bibliography{../bibtex}

\end{document}
% EOF